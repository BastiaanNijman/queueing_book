\author{Nicky D. van  Foreest}

\begin{document}
\frontmatter
\maketitle

Changes:
\begin{itemize}
\item Figure 8
\item Section~\ref{sec:queu-proc-as}.
\item Section \ref{sec:constr-discr-time}, added python code to a few exercises to show how to implement the recursions.
\item Moved part of \cref{ex:25} to \cref{ex:97}. #This doesn't work, gives question marks. don't know whats wrong
\item Moved old intro of \cref{sec:level-cross-balance} to \cref{ex:98}.
\item Formulas in intro \cref{sec:mnmn1}.
\item \cref{sec:mxm1-queue:-expected}: rewritten
\item \cref{sec:setups-batch-proc} restructured
\item Added \cref{ex:mg1-3}. Will not be used in the midterm.
\end{itemize}


\tableofcontents

\chapter{Introduction}
\label{cha:introduction}
\addcontentsline{toc}{chapter}{Introduction}

\input{tex_files/intro.tex}

\mainmatter

\chapter{Construction and Simulation of Queueing Systems}
\label{cha:single-stat-queu}

In this chapter we start with a discussion of the Poisson process.
We then construct queueing processes in discrete time and apply the Poisson process to model the number of arrivals in periods of fixed length.
In~\cref{sec:expon-distr} we relate the exponential distribution to the Poisson distribution.
The exponential distribution often serves as a good model for inter-arrival times of individual jobs.
As such, this is a key component of the construction of queueing processes in continuous time.
As it turns out, both ways to construct queueing processes are easily implemented as computer programs, thereby allowing us to use simulation to analyze queueing systems.
In passing, we develop a number of performance measures to provide insight into the (transient and average) behavior of queueing processes.
We then introduce a useful set of shorthands to distinguish between different queueing models, and finish the chapter with a motivation why we focus on a steady-state analysis of queueing systems in the remainder of the book.

We assume that you  \emph{know all} results of~\cref{sec:preliminaries}. 

\input{tex_files/preliminaries.tex}
\input{tex_files/poissondistribution.tex}
\input{tex_files/constructiondiscretetime.tex}
\input{tex_files/expdistribution.tex}
\input{tex_files/constructioncontinuoustime.tex}
\input{tex_files/kendall.tex}
\input{tex_files/random_walk.tex}
\ifshowextra
   \input{tex_files/part_1_exams.tex}
\fi



\chapter{Analytical Models}
\label{cha:analytical-models}

In this chapter we focus on developing analytic models for various queueing systems in steady-state.
In the analysis we use sample-path and level-crossing arguments to count how often certain events occur as a function of time.
Then we define probabilities in terms of limits of fractions of these counting processes.
Like this the performance measures can be explicitly computed for the statistical analysis of (simulations of) queueing systems.


As a reminder, we keep the discussion in these notes mostly at an intuitive level, and refer to \cite{el-taha98:_sampl_path_analy_queuein_system} for proofs and further background.

\input{tex_files/ratestability.tex}
\input{tex_files/renewal_reward.tex}
\input{tex_files/empiricalperfmeasures.tex}
\input{tex_files/levelcrossing.tex}
\input{tex_files/mm1.tex}
\input{tex_files/mnmn1.tex}
\input{tex_files/pasta.tex}
\input{tex_files/little.tex}
\input{tex_files/mxm1_pk.tex}
\input{tex_files/mg1.tex}
\input{tex_files/batcharrivals.tex}
\input{tex_files/mg1distributionqueuelength.tex}
% \input{tex_files/relationmxm1andmg1.tex}
%\input{tex_files/mg1density.tex}
\input{tex_files/figure_summaries.tex}

\ifshowextra
   \input{tex_files/part_2_exams.tex}
\fi

\chapter{Approximate Models}
\label{cha:approximate-models}
In this chapter we first consider the very useful formula of Sakasegawa to approximate the average waiting time in queue for the $G/G/c$ queue.
We then illustrate how to use this formula to estimate waiting time in three examples in which the service process is interrupted.
In the first case the server has to produce jobs from different families, and there is a change-over time required to switch from one production family to another.
As such setups reduce the time the server has available to serve jobs, the load must increase.
In fact, to reduce the load, the server produces in batches of fixed sizes.
In the second case, the server sometimes requires small adjustments, for instance, to prevent the production quality to degrade below a certain level.
Clearly, such adjustments are typically not required during a job's service; however, they can occur at arbitrary moments in time.
Thus, this is different from batch production in which the batch sizes are constant.
In the third example, quality problems or break downs can occur during a job's service.
For each case we develop a model to analyze the influence of the interruptions on average job sojourn times.


\input{tex_files/gg1.tex}
\input{tex_files/setup_times.tex}
\input{tex_files/adjustments.tex}
\input{tex_files/failures.tex}
%\input{tex_files/process_batches.tex}


\chapter{Queueing Control}

In the queueing systems we analyzed up to now, the server is always present to serve jobs in the system. However, this condition is not always satisfied.
As an example, consider a queueing system in which there is a cost associated with switching on and off the server.
For instance, in some cases the server has to be set-up for operation; in other cases, the operator of a machine has to move from one place in the factory to another.
To reduce the cost, a so-called $N$-policy can be used, which works as follows, cf.~\cref{ex:n-policies}.
As soon as the system becomes empty (and the server idle), we switch off the server.
Then we wait until $N$ or more jobs arrived and then switch on the server.
The server processes jobs until the system is empty again, and then switches off again, and so on.
Thus, we use an $N$-policy to \emph{control} the queueing system, in particular the server, and the task is to find a switching threshold~$N$ that minimizes the long-run average cost.

Observe that under such policies the server occupancy can also increase.
In fact, this sometimes seems to the policy at dentists or hospitals: wait until the waiting room is quite full, and then start serving patients.
Like this the server minimizes idle time, and, in the example of a GP, the server (GP) does not have to wait for patients that might be late.

In this chapter we study the $M/M/1$ queue and $M/G/1$ under a $N$-policy, and then consider a $T$-policy.
We next focus on a policy that controls the server rate as a function of waiting time in the system.


We point out that the techniques developed in this chapter extend (way) beyond just queueing theory; they are worth memorizing.
Moreover, we illustrate many tools and results of the previous chapters.
Moreover, the concepts we introduce here can be generalized to (optimal) stopping problems, which find many applications beyond queueing, such in finance, inventory theory, decision theory, and so on.


\input{tex_files/n_policies_mm1.tex}
\input{tex_files/n_policies_mg1.tex}

% \ifshowextra
%    \input{tex_files/part_3_exams.tex}
% \fi

\chapter{Queueing Networks}
\label{sec:notes-relat-chapt2}

We refer to the relevant sections of Zijm's book for background. Here we just include the solutions and repair a few typos. 
\input{tex_files/open_single_class.tex}
\input{tex_files/tandem.tex}
%\input{tex_files/open_general.tex}

%\input{tex_files/deterministic_networks.tex}
%\input{tex_files/gordon_newell.tex}
%\input{tex_files/convolution.tex}
%\input{tex_files/mva.tex}
%\input{tex_files/mda.tex}

\ifshowextra
   \input{tex_files/part_4_exams.tex}
\fi



\backmatter

\addcontentsline{toc}{chapter}{Bibliography}
\phantomsection
\bibliographystyle{plainnat}
\bibliography{biblio_nicky}


\chapter{Notation}
\label{sec:notation}
%\addcontentsline{toc}{chapter}{Notation}
\input{tex_files/notation.tex}

\chapter{Formula Sheet}
%\addcontentsline{toc}{chapter}{Formula Sheet}
\input{tex_files/formula_sheet.tex}

\addcontentsline{toc}{chapter}{Index}
\phantomsection
\printindex

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "companion"
%%% End:
